# property taken from 2018 WM Survey DWG
proppts = [
    [-644, 2380],
    [-457, 2064],
    [-451, 1904],
    [-578, 1654],
    [-624, 1470],
    [-673, 1579],
    [-806, 1669],
    [-800, 2009],
    [-862, 2309]
    ]

# monopod survey 5/27/21
horsepts = [
    [-469.81, 1928.73],
    [-488.51, 1903.72],
    [-517.62, 1890.01],
    [-572.02, 1876.52],
    [-590.65, 1861.59],
    [-617.51, 1854.86],
    [-643.08, 1855.40],
    [-679.72, 1863.53],
    [-716.17, 1880.55],
    [-743.18, 1911.50],
    [-766.27, 1947.05],
    [-780.30, 1989.13],
    [-786.57, 2044.97],
    [-793.37, 2097.94],
    [-782.18, 2117.00],
    [-745.57, 2123.52],
    [-745.58, 2123.49],
    [-750.62, 2147.55],
    [-790.09, 2141.54],
    [-801.76, 2148.42],
    [-814.63, 2169.50],
    [-829.34, 2163.91],
    [-818.83, 2113.80],
    [-800.86, 2037.84],
    [-794.34, 1966.27],
    [-787.11, 1948.70],
    [-766.87, 1913.13],
    [-770.79, 1902.29],
    [-781.41, 1888.04],
    [-785.35, 1873.30],
    [-777.48, 1872.48],
    [-770.32, 1886.67],
    [-758.64, 1899.47],
    [-730.45, 1867.07],
    [-707.87, 1845.26],
    [-697.78, 1826.98],
    [-691.52, 1822.06],
    [-672.97, 1816.98],
    [-644.24, 1812.56],
    [-615.23, 1813.15],
    [-566.84, 1823.47],
    [-543.23, 1834.23],
    [-519.25, 1850.02],
    [-507.06, 1866.63],
    [-500.59, 1880.48],
    [-468.79, 1903.69],
    [-459.34, 1928.01]
    ]

waypts = [
    [ -787.36,  2298.03],     #10 
    [ -647.55,  2108.54],     #11 speed bump
    [ -619.57,  2091.62],     #12 T seam
    [ -599.97,  2236.32],     #13 workshop F 
    [ -578.94,  2247.67],     #14 driveway center F
    [ -490.20,  2097.75],     #15 gravel rev 210430
    [ -471.80,  2053.82],     #16 fig tree fork F
    [ -532.36,  1963.03],     #17 stairs pivot
    [ -592.93,  1931.82],     #18 shed #3/#4 F
    [ -526.33,  1863.82],     #19 longe center
    [ -661.79,  1842.34],     #20 stall ctr
    [ -511.84,  2145.63],     #21 E dway start
    [ -548.45,  1951.78],     #22 hut row bend F
    [ -619.07,  2315.06],     #23 trash
    [ -599.72,  2290.03],     #24 EF east entry
    [ -665.89,  2108.14],     #25 ref corner - F
    [ -646.13,  2126.38],     #26 hose bib - F
    # [ -640.51,  2177.75],     #27 rose bush - F
    [ -640.51,  2179.75],     #27 rose bush - F 210102 modified to avoid roses
    [ -624.85,  2235.41],     #28 boat corner - F 201230 - refounded
    [ -684.91,  2276.04],     #29 EF middle - F
    [ -644.70,  2261.65],     #30 office gap
    [ -653.41,  2229.63],     #31 EF rose gap
    ]

# personal survey 210506
housepts = [
    [-521, 2074],
    [-551, 2059],
    [-561, 2056],
    [-578, 2051],
    [-576, 2044],
    [-594, 2039],
    [-598, 2051],
    [-624, 2043],
    [-632, 2070],
    [-605, 2077],
    [-610, 2093],
    [-592, 2098],
    [-590, 2093],
    [-573, 2098],
    [-576, 2108],
    [-543, 2123]
    ]
hut1 = [
    [-639.91,1955.08],
    [-642.17,1945.43],
    [-630.83,1942.62],
    [-628.49,1952.45]
    ]
hut2 = [
    [-620.55,1951.13],
    [-613.23,1950.71],
    [-613.88,1943.62],
    [-621.21,1944.38]
    ]
hut3 = [
    [-604.58,1951.39],
    [-597.77,1952.87],
    [-596.32,1945.91],
    [-603.32,1944.72]
    ]
hut4 = [
    [-587.80,1954.31],
    [-581.14,1955.12],
    [-580.05,1948.40],
    [-586.86,1947.46]
    ]
lhouse = [
    [-583.55,2182.98],
    [-571.94,2189.43],
    [-576.49,2197.60],
    [-588.09,2191.15]
    ]
horsecanopy = [
    [-582.28,2219.30],
    [-596.56,2223.87],
    [-604.27,2197.31],
    [-590.79,2192.48]
    ]
workshop = [
    [-612.08, 2226.97],
    [-617.51, 2207.77],
    [-607.15, 2204.32],
    [-599.91, 2222.88]
    ]
backpts = [
    [-648, 2374],
    [-503, 2130],
    [-527, 2148],
    [-657, 2365]
    ]

frontpts = [
    [-807, 2328],
    [-753, 2260],
    [-657, 2113],
    [-666, 2107],
    [-755, 2242],
    [-820, 2321]
    ]
# monopod 5/17-20/21
eftrees = [
    [-697.20, 2341.37],
    [-792.16, 2320.76],
    [-729.78, 2345.90],
    [-720.57, 2349.01],
    [-694.93, 2356.44],
    [-685.66, 2360.03],
    [-674.59, 2341.62],
    [-663.53, 2135.12],
    [-733.72, 2244.50],
    [-742.13, 2255.65],
    [-752.26, 2273.00],
    [-669.90, 2146.72],
    [-680.53, 2171.42],
    [-689.53, 2179.68],
    [-696.82, 2191.34],
    [-708.19, 2200.21],
    [-711.65, 2215.13],
    [-718.54, 2224.65],
    [-725.43, 2234.66],
    [-650.78, 2345.99],
    [-713.81, 2286.41],
    [-722.30, 2298.43],
    [-707.71, 2308.08],
    [-685.31, 2306.48],
    [-553.51, 2165.42],
    [-587.32, 2149.28],
    [-611.69, 2246.94],
    [-639.16, 2297.69],  
    [-662.07, 2222.55],
    [-648.70, 2240.69],
    [-647.59, 2256.48],
    [-635.22, 2266.86],
    [-623.87, 2271.28],
    [-654.17, 2160.81],
    [-670.29, 2180.33],
    [-685.47, 2201.39],
    [-708.33, 2233.64],
    [-715.14, 2244.91],
    [-721.25, 2254.68],
    [-729.04, 2266.83],
    [-687.36, 2228.05],
    [-680.73, 2244.00],
    [-701.38, 2250.83],
    [-698.00, 2262.03],
    [-747.20, 2327.20],
    [-656.20, 2289.77],
    [-660.87, 2305.83],
    [-648.90, 2324.98]
    ]
wbtrees = [
    [-760.29,2209.29],
    [-821.69,2310.97],
    [-730.56,2202.30],
    [-738.82,2212.74],
    [-745.20,2223.79],
    [-753.01,2235.79],
    [-764.20,2248.13],
    [-773.72,2260.13],
    [-784.21,2272.11],
    [-795.33,2283.69],
    [-840.92,2306.10],
    [-794.11,2180.35],
    [-793.00,2206.61],
    [-751.47,2198.79],
    [-771.92,2222.58],
    [-793.16,2225.71],
    [-795.24,2245.71],
    [-781.75,2234.82],
    [-807.87,2253.03],
    [-754.39,2169.04],
    [-763.59,2179.40],
    [-738.58,2182.73],
    [-747.13,2160.29],
    [-775.00,2193.29]
    ]
citrees = [
    [-685.73,2092.00],
    [-693.57,2107.84],
    [-698.55,2078.46],
    [-719.57,2119.18],
    [-704.57,2091.59],
    [-481.65,2019.45],
    [-537.32,2000.22],
    [-657.96,2010.35],
    [-606.75,1962.21],
    [-623.25,1975.01],
    [-479.41,1959.84],
    [-644.96,1996.98],
    ]

from tkinter import *
from tkinter.font import Font
import serial
import RPi.GPIO as GPIO
import math
GPIO.setmode(GPIO.BCM)
GPIO.setup(21, GPIO.IN, pull_up_down=GPIO.PUD_UP) # green
GPIO.setup(5, GPIO.IN, pull_up_down=GPIO.PUD_UP) # black
GPIO.setup(13, GPIO.IN, pull_up_down=GPIO.PUD_UP) # red
GPIO.setup(7, GPIO.IN, pull_up_down=GPIO.PUD_UP) # blue
GPIO.setup(10, GPIO.IN, pull_up_down=GPIO.PUD_UP) # yellow

ser = serial.Serial(port='/dev/ttyS0',      #xbee to rover
    baudrate=9600,
    parity=serial.PARITY_NONE,
    stopbits=serial.STOPBITS_ONE,
    bytesize=serial.EIGHTBITS,
    timeout=1
    )
rhdg = math.radians(450 - 98)       # x-y initial heading to compass
strhdg = 0
track = []
lat = 0.0
lon = 0.0
pathflag = False
butngreen = False
butnred = False
butnblack = False
butnblue = False
butnyellow = False
arrlen = 75
scale = 1.0
# stlat = 2400
# stlon = -440
stlat = 2400
stlon = 950
mode = 1        #zoom in
mx = 0
my = 0

# ==============================================================================
try:
    pathfile = open("path.txt", 'r')
    pathflag = True
    
except IOError:
    pass

def chart(mstr):
    global arena
    global bdrv
    global charter
    global canvas
    global fdrv
    global lunge
    global plot
    global rez

    points = usf2pix(proppts, scale, stlat, stlon)
    plot = canvas.create_polygon(points, outline='black', fill='lemon chiffon', width=1)
    horse = usf2pix(horsepts, scale, stlat, stlon)
    arena = canvas.create_polygon(horse, outline='black', fill='gold', width=1)
    longe =usf2pix([[-526-25, 1863.82-25],[-526+25, 1863.82+25]], scale, stlat, stlon)
    lunge = canvas.create_oval(longe[0], longe[1], longe[2], longe[3], outline='black', \
        fill='gold', width=1)
    
    house = usf2pix(housepts, scale, stlat, stlon)
    rez = canvas.create_polygon(house, outline='black', fill='red', width=1, tags="bldg")
    h1 = usf2pix(hut1, scale, stlat, stlon)
    canvas.create_polygon(h1, outline='black', fill='red', width=1, tags="bldg")
    h2 = usf2pix(hut2, scale, stlat, stlon)
    canvas.create_polygon(h2, outline='black', fill='red', width=1, tags="bldg")
    h3 = usf2pix(hut3, scale, stlat, stlon)
    canvas.create_polygon(h3, outline='black', fill='red', width=1, tags="bldg")
    h4 = usf2pix(hut4, scale, stlat, stlon)
    canvas.create_polygon(h4, outline='black', fill='red', width=1, tags="bldg")
    casita = usf2pix(lhouse, scale, stlat, stlon)
    canvas.create_polygon(casita, outline='black', fill='red', width=1, tags="bldg")
    canopy = usf2pix(horsecanopy, scale, stlat, stlon)
    canvas.create_polygon(canopy, outline='black', fill='red', width=1, tags="bldg")
    work = usf2pix(workshop, scale, stlat, stlon)
    canvas.create_polygon(work, outline='black', fill='red', width=1, tags='bldg')
    
    back = usf2pix(backpts, scale, stlat, stlon)
    bdrv = canvas.create_polygon(back, outline='black', fill='gray75', width=1)
    front = usf2pix(frontpts, scale, stlat, stlon)
    fdrv = canvas.create_polygon(front, outline='black', fill='gray75', width=1)
    
    trees = usf2pix(eftrees, scale, stlat, stlon)
    llen = len(trees)
    rad = scale * 3
    for i in range(0, llen, 2):
        canvas.create_oval(trees[i]-rad, trees[i+1]-rad, trees[i]+rad, trees[i+1]+rad, \
            fill='green2', outline='black', width=2, tags = 'forest')
    trees = usf2pix(wbtrees, scale, stlat, stlon)
    llen = len(trees)
    rad = scale * 3
    for i in range(0, llen, 2):
        canvas.create_oval(trees[i]-rad, trees[i+1]-rad, trees[i]+rad, trees[i+1]+rad, \
            fill='green2', outline='black', width=2, tags = 'forest')
    trees = usf2pix(citrees, scale, stlat, stlon)
    llen = len(trees)
    rad = scale * 3
    for i in range(0, llen, 2):
        canvas.create_oval(trees[i]-rad, trees[i+1]-rad, trees[i]+rad, trees[i+1]+rad, \
            fill='green2', outline='black', width=2, tags = 'forest')

    tracks = usf2pix(track, scale, stlat, stlon)
    llen = len(tracks)
    for i in range(0, llen, 2):
        canvas.create_text(tracks[i], tracks[i+1], text='x', fill='blue', tags = 'path')

def xspot(mstr, xlon, xlat):
    spot = usf2pix([[xlon, xlat]], scale, stlat, stlon)
    canvas.create_text(spot[0], spot[1], text='x', fill='blue', tags = 'path')
          
def guage(mstr):
    xarrow = arrlen * math.cos(rhdg)
    yarrow = arrlen * math.sin(rhdg)
    rose.delete('arrow')
    rose.create_line(110-xarrow, 110+yarrow, 110 + xarrow, 110-yarrow, arrow=LAST, \
        arrowshape=(20,25,5), width=8,fill="deep sky blue", tags="arrow")
    if (strhdg < -1 or strhdg > 1):
        strad = math.radians(strhdg)
        xarrow = arrlen * math.cos(rhdg - strad)
        yarrow = arrlen * math.sin(rhdg - strad)
        if (strhdg < 0):
            rose.create_line(110, 110, 110+xarrow, 110-yarrow, arrow = LAST, \
                width = 3, fill = "red2", tags='arrow')
        else:
            rose.create_line(110, 110, 110+xarrow, 110-yarrow, arrow = LAST, \
                width = 3, fill = "green2", tags='arrow')

# convert array of USfeet pairs into linear array of pixels (in pairs)
# slat, slon starting lat/lon usf from 34-14, -119-04
def usf2pix(usf, gscale, slat, slon):
    pix = []
    for x in usf:
#         pix.insert(0, int(gscale * (slon-x[0])))   # North:x coord, East:y coord
        pix.insert(0, int(gscale * (slat-x[1])))
        pix.insert(0, int(gscale * (slon+x[0])))
    return pix

# having an event handler for button down as well as button release may look redundant
# but touch and mouse event sequences are not identical, to wit: touch gives movement followed
# by button down, mouse gived button then movement

def bpress(event):
    global mx
    global my
    mx = event.x
    my = event.y
    
def bupress(event):
    global mx
    global my
    mx = 0
    my = 0
    
def mouse(event):
    global mx
    global my
    global stlat
    global stlon
    if (mode == 0):
        return

    if (mx == 0 and my == 0):
        mx = event.x
        my = event.y
        return
    x = event.x - mx
    y = event.y - my
#     stlat += x/scale  # North:x coord, East:y coord
#     stlon += y/scale
    stlat += y/scale
    stlon += x/scale
    
#    print("move")
#     print(str(event.x)+" "+str(event.y))
#     print(str(int(stlat))+" "+str(int(stlon)))
    canvas.move(plot, x, y)
    canvas.move(bdrv, x, y)
    canvas.move(fdrv, x, y)
    canvas.move(arena, x, y)
    canvas.move(lunge, x, y)
    canvas.move('bldg', x, y)
    canvas.move('forest', x, y)
    canvas.move('path', x, y)
    mx = event.x
    my = event.y

def taptap(event):
    global stlat
    global stlon
    global scale
    global rez
    global fdrv
    global bdrv
    global plot
    global arena
    global lunge
    
    if (mode == 0):
#         lat = stlat - event.x/scale  # North:x coord, East:y coord
#         lon = stlon - event.y/scale
        lat = stlat - event.y/scale # North: y coord East:x coord
        lon = event.x/scale - stlon
#        print (str(lat)+"/"+str(lon))
        pnt = usf2pix([[lon, lat]], scale, stlat, stlon)
        canvas.create_rectangle(pnt[0], pnt[1], pnt[0]+4, pnt[1]+4, \
            fill='blue',outline='blue')
        msg = '{GL%7.2f}' % lon
        ser.write(msg.encode('utf-8'))
        print(msg)
        msg = '{GN%7.2f}' % lat
        ser.write(msg.encode('utf-8'))
        print(msg)
        return
    if mode > 0:
#         stlat = stlat - (event.x/scale)/3  # North:x coord, East:y coord
#         stlon = stlon - (event.y/scale)/3
        stlat = stlat - (event.y/scale)/3
        stlon = stlon - (event.x/scale)/3
        scale *= 1.5
    else:
#         stlat = stlat + (event.x/scale)/2  # North:x coord, East:y coord
#         stlon = stlon + (event.y/scale)/2
        stlat = stlat + (event.y/scale)/2
        stlon = stlon + (event.x/scale)/2
        scale *= 2/3
        
#     print("zoom")
#     print(str(event.x)+" "+str(event.y))
#     print(str(int(stlat))+" "+str(int(stlon)))
    canvas.delete(arena)
    canvas.delete(plot)
    canvas.delete(lunge)
    canvas.delete(fdrv)
    canvas.delete(bdrv)
    canvas.delete('bldg')
    canvas.delete('forest')
    canvas.delete('path')
    chart(root)

class App:
    
    def __init__(self, master):
        self.mode = IntVar()
        self.ibuffer = ""
        self.piflag = False

        # telemetry array ===========================================
        data = Frame(master)
        data.place(x=20,y=470)
        sta=Label(data,text="STS:", font=(None,15))
        sta.grid(row=0,column=0)
        spd=Label(data,text="SPD:", font=(None,15))
        spd.grid(row=1,column=0)
        hdg=Label(data,text="HDG:", font=(None,15))
        hdg.grid(row=2,column=0)
        ste=Label(data,text="STR:", font=(None,15))
        ste.grid(row=3,column=0)
        dtgl=Label(data,text="DTG:", font=(None,15))
        dtgl.grid(row=4,column=0)
        ctgl=Label(data,text="CTG:", font=(None,15))
        ctgl.grid(row=5,column=0)
        xtel=Label(data,text="XTE:", font=(None,15))
        xtel.grid(row=6,column=0)
        lat=Label(data,text="ACC:", font=(None,15))
        lat.grid(row=7,column=0)

        self.status = StringVar()
        Label(data,width=5,font=(None,20),bg="white",fg="blue", \
              borderwidth=1,relief="solid",\
              textvariable=self.status).grid(row=0,column=1)
        self.speed = StringVar()
        Label(data,width=5,font=(None,20),bg="white",fg="blue", \
              borderwidth=1,relief="solid",\
              textvariable=self.speed).grid(row=1,column=1)
        self.head = StringVar()
        Label(data,width=5,font=(None,20),bg="white",fg="blue", \
              borderwidth=1,relief="solid",\
              textvariable=self.head).grid(row=2,column=1)
        self.steer = StringVar()
        Label(data,width=5,font=(None,20),bg="white",fg="blue", \
              borderwidth=1,relief="solid",\
              textvariable=self.steer).grid(row=3,column=1)
        self.dtg = StringVar()
        Label(data,width=5,font=(None,20),bg="white",fg="blue", \
              borderwidth=1,relief="solid",\
              textvariable=self.dtg).grid(row=4,column=1)
        self.ctg = StringVar()
        Label(data,width=5,font=(None,20),bg="white",fg="blue", \
              borderwidth=1,relief="solid",\
              textvariable=self.ctg).grid(row=5,column=1)
        self.xte = StringVar()
        Label(data,width=5,font=(None,20),bg="white",fg="blue", \
              borderwidth=1,relief="solid",\
              textvariable=self.xte).grid(row=6,column=1)
        self.acc = StringVar()
        Label(data,width=5,font=(None,20),bg="white",fg="blue", \
              borderwidth=1,relief="solid",\
              textvariable=self.acc).grid(row=7,column=1)
        
        # Steering button array ========================================
        steer = Frame(master)
        steer.place(x=550,y=700)
        l35 = Button(steer, text="<<<", command = lambda:self.dxmit('7'))
        l35.config(width=3,height=1,font=(None,15),bg="pink",fg="black",borderwidth=4)
        l35.grid(row=0,column=0)
        
        l5 = Button(steer, text="<<", command = lambda:self.dxmit('4'))
        l5.config(width=3,height=1,font=(None,15),bg="pink",fg="black",borderwidth=4)
        l5.grid(row=0,column=1)
        
        l1 = Button(steer, text="<", command = lambda:self.dxmit('1'))
        l1.config(width=3,height=1,font=(None,15),bg="pink",fg="black",borderwidth=4)
        l1.grid(row=0,column=2)
        
        z0 = Button(steer, text=".", command = lambda:self.dxmit('5'))
        z0.config(width=3,height=1,font=(None,25),bg="linen",fg="black",borderwidth=4)
        z0.grid(row=0,column=3)
        
        r1 = Button(steer, text=">", command = lambda:self.dxmit('3'))
        r1.config(width=3,height=1,font=(None,15),bg="green2",fg="black",borderwidth=4)
        r1.grid(row=0,column=4)
        
        r5 = Button(steer, text=">>", command = lambda:self.dxmit('6'))
        r5.config(width=3,height=1,font=(None,15),bg="green2",fg="black",borderwidth=4)
        r5.grid(row=0,column=5)

        r35 = Button(steer, text=">>>", command = lambda:self.dxmit('9'))
        r35.config(width=3,height=1,font=(None,15),bg="green2",fg="black",borderwidth=4)
        r35.grid(row=0,column=6)

        # speed button array ===================================================
        speed = Frame(master)
        speed.place(x=1150, y=500)
        fmax = Button(speed, text = "+", command = lambda:self.dxmit('2'))
        fmax.config(width = 3, height = 2, font=(NONE,15), \
            bg="green2",fg="black",borderwidth=4)
        fmax.grid(row=0,column=0)

        f0 = Button(speed, text = "0", command = lambda:self.dxmit('0'))
        f0.config(width = 3, height = 4, font=(NONE,15), \
            bg="linen",fg="black",borderwidth=4)
        f0.grid(row=3,column=0)
        
        rmax = Button(speed, text = "-", command = lambda:self.dxmit('8'))
        rmax.config(width = 3, height = 2, font=(NONE,15), \
            bg="pink",fg="black",borderwidth=4)
        rmax.grid(row=6,column=0)
        
        # mode menu ===========================================================
        radio = Frame(master)
        radio.place(x=20, y=20)
        rb1 = Radiobutton(radio, text="Standby", variable=self.mode, value = 0, \
            anchor=W, command=lambda:self.mode_set(master, self.mode.get()))
        rb1.config(width = 7, height = 2, font=(NONE,15))
        rb1.grid(row=0, column=0)
        
        rb2 = Radiobutton(radio, text="Auto", variable=self.mode, value = 1, \
            anchor=W, command=lambda:self.mode_set(master, self.mode.get()))
        rb2.config(width = 6, height = 2, font=(NONE,15))
        rb2.grid(row=1, column=0)
        rb3 = Radiobutton(radio, text="Path", variable=self.mode, value = 2, \
            anchor=W, command=lambda:self.mode_set(master, self.mode.get()))
        rb3.config(width = 6, height = 2, font=(NONE,15))
        rb3.grid(row=2, column=0)
        
        rb4 = Radiobutton(radio, text="PanTilt", variable=self.mode, value = 3, \
            anchor=W, command=lambda:self.mode_set(master, self.mode.get()))
        rb4.config(width = 6, height = 2, font=(NONE,15))
        rb4.grid(row=3, column=0)
        
        rb5 = Radiobutton(radio, text="Misc", variable=self.mode, value = 4, \
            anchor=W, command=lambda:self.mode_set(master, self.mode.get()))
        rb5.config(width = 6, height = 2, font=(NONE,15))
        rb5.grid(row=4, column=0)
        
# enlarge button array ===================================================
        zoom = Frame(root)
        zoom.place(x=825, y=200)
        fmax = Button(zoom, text = "+", command = lambda:scaler(1))
        fmax.config(width = 1, height = 1, font=(NONE,15), \
            bg="green2",fg="black",borderwidth=4)
        fmax.grid(row=0,column=0)

        rmax = Button(zoom, text = "-", command = lambda:scaler(-1))
        rmax.config(width = 1, height = 1, font=(NONE,15), \
            bg="pink",fg="black",borderwidth=4)
        rmax.grid(row=1,column=0)
                
        rmax = Button(zoom, text = "X", command = lambda:scaler(0))
        rmax.config(width = 1, height = 1, font=(NONE,15), \
            bg="deep sky blue",fg="black",borderwidth=4)
        rmax.grid(row=2,column=0)
        
        def scaler(scl):
            global mode
            mode = scl
#
# compass rose ============================================================
        rose.create_oval(25, 25, 195, 195, width=1, outline='black', fill="black")
        ffont = Font(family="URW Chancery L", size=20, weight = "bold")
        efont = Font(family="URW Chancery L", size=16)
        rose.create_text(108, 8, text="N", font = ffont, angle=0)
        rose.create_text(105, 210, text="S", font = ffont, angle=0)
        rose.create_text(8, 112, text="W", font = ffont, angle=90)

        rose.create_text(212, 108, text="E", font = ffont, angle=270)
        rose.create_text(180, 40, text = "NE", font = efont, angle=315)
        rose.create_text(185, 175, text = "SE", font = efont, angle=225)
        rose.create_text(45, 180, text = "SW", font = efont, angle=135)
        rose.create_text(45, 40, text = "NW", font = efont, angle=45)
        
    # destroy old frames when changing mode via radiobuttons ====================
    def mode_set(self, mstr, val):

        try:
            lister.destroy()
        except:
            pass
        try:
            auto.destroy()
        except:
            pass
        try:
            pntlt.destroy()
        except:
            pass
        try:
            miscer.destroy()
        except:
            pass
        
        if (val == 0):
            chart(mstr)
            guage(mstr)
            
        if (val == 1):
            self.auto_turns(mstr)
            
        if (val == 2):
            self.paths(mstr)
            
        if (val == 3):
            self.pantilt(mstr)
            
        if (val == 4):
            self.misc(mstr)
           
    # frame for wapoint/route selection =====================================================    
    def paths(self, mstr):
        global lister
        lister = Frame(mstr)
        lister.place(x=200, y=470)
        lab = Label(lister, text="Select NAV path")
        lab.grid(row=0, column=0)
        lscroll = Scrollbar(lister, orient=VERTICAL)
        lbox =Listbox(lister, height=4, selectmode=SINGLE,font=(NONE,15), \
            yscrollcommand=lscroll.set)
        lbox.insert(END, "R03 - E.F. drive")
        lbox.insert(END, "R04 - hut row")
        lbox.insert(END, "W13 - canopy")
        lbox.insert(END, "W14 - driveway center")
        lbox.insert(END, "W23 - trash cans")
        lbox.insert(END, "W27 - rose bush")
        lbox.insert(END, "W29 - E,F, middle")
        lbox.insert(END, "W30 - office gap")
        lbox.insert(END, "W31 - rose passage")

        lbox.grid(row=1, column=0)
        lscroll.config(width=25, command=lbox.yview)
        lscroll.grid(row=1, column=1, sticky=N+S)
        ex = Button(lister, text="Execute", command=lambda:self.lrevert(lbox.get(ANCHOR)))
        ex.config(width=6, height=3, font=(None,15), bg="green2")
        ex.grid(row = 2, column = 0)
        quit = Button(lister, text="Cancel", command=lambda:self.lrevert('000'))
        quit.config(width=6, height=3, font=(None,15), bg="red",fg="black")
        quit.grid(row=4, column=0)

    #could call fxmit directly if no radiobutton action wanted
    def lrevert(self, pth):
        self.fxmit(pth[1:3])
        lister.destroy()
        self.mode.set(0)

    # AUTO mode button array ==================================================
    def auto_turns(self, mstr):
        global auto
        auto = Frame(mstr)
        auto.place(x=250, y=470)
        bs=Button(auto, text="Start", command = lambda:self.exmit('2'))
        bs.config(width=4,height=2,font=(None,15),bg="white",fg="black")
        bs.grid(row=0,column=0,columnspan=2)
        
        bl90=Button(auto, text="< 90", command = lambda:self.exmit('1'))
        bl90.config(width=3,height=2,font=(None,15),bg="pink",fg="black")
        bl90.grid(row=1,column=0)
        
        br90=Button(auto, text="90 >", command = lambda:self.exmit('3'))
        br90.config(width=3,height=2,font=(None,15),bg="green2",fg="black")
        br90.grid(row=1,column=1)
        
        blt=Button(auto, text="T 90", command = lambda:self.exmit('4'))
        blt.config(width=3,height=2,font=(None,15),bg="pink",fg="black")
        blt.grid(row=2,column=0)
        
        brt=Button(auto, text="90 T", command = lambda:self.exmit('6'))
        brt.config(width=3,height=2,font=(None,15),bg="green2",fg="black")
        brt.grid(row=2,column=1)
        
        bl180=Button(auto, text="< 180", command = lambda:self.exmit('7'))
        bl180.config(width=3,height=2,font=(None,15),bg="pink",fg="black")
        bl180.grid(row=3,column=0)
        
        br180=Button(auto, text="180 >", command = lambda:self.exmit('9'))
        br180.config(width=3,height=2,font=(None,15),bg="green2",fg="black")
        br180.grid(row=3,column=1)
        
        bcan=Button(auto, text="Cancel", command=self.arevert)
        bcan.config(width=4,height=2,font=(None,15),bg="yellow",fg="black")
        bcan.grid(row=4,column=0,columnspan=2)

    # cancel AUTO mode
    def arevert(self):
        auto.destroy()
        self.mode.set(0)
        self.exmit('0')
           
    # AUTO mode button array ==================================================
    def pantilt(self, mstr):
        global pntlt
        pntlt = Frame(mstr)
        pntlt.place(x=200, y=490)
        bup=Button(pntlt, text="tilt Up", command = lambda:self.dxmit('U'))
        bup.config(width=5,height=2,font=(None,15),bg="cyan",fg="black")
        bup.grid(row=0,column=0,columnspan=3)
        
        bleft=Button(pntlt, text="pan left", command = lambda:self.dxmit('L'))
        bleft.config(width=5,height=2,font=(None,15),bg="pink",fg="black")
        bleft.grid(row=1,column=0)
        
        bctr=Button(pntlt, text="center", command = lambda:self.dxmit('C'))
        bctr.config(width=5,height=2,font=(None,15),bg="white",fg="black")
        bctr.grid(row=1,column=1)
        
        brght=Button(pntlt, text="pan right", command = lambda:self.dxmit('R'))
        brght.config(width=5,height=2,font=(None,15),bg="green2",fg="black")
        brght.grid(row=1,column=2)
        
        bdwn=Button(pntlt, text="tilt down", command = lambda:self.dxmit('D'))
        bdwn.config(width=5,height=2,font=(None,15),bg="sandy brown",fg="black")
        bdwn.grid(row=2,column=0,columnspan=3)
        
        bcan=Button(pntlt, text="Cancel", command=self.ptquit)
        bcan.config(width=5,height=2,font=(None,15),bg="yellow",fg="black")
        bcan.grid(row=4,column=0,columnspan=3)

    def ptquit(self):
        pntlt.destroy()
        self.mode.set(0)
        
    # misc commands ==========================================================
    def misc(self, mstr):
        global miscer
        miscer = Frame(mstr)
        miscer.place(x=200, y=450)
        msb1=Button(miscer, text="Diag", command=lambda:self.txmit('0'))
        msb1.config(width=4,height=2,font=(None,15),bg="white",fg="black")
        msb1.grid(row=0,column=0)
        
        msb2=Button(miscer, text="Mark", command=lambda:self.txmit('2'))
        msb2.config(width=4,height=2,font=(None,15),bg="white",fg="black")
        msb2.grid(row=2,column=0)
        
        msb3=Button(miscer, text="Pic", command=lambda:self.txmit('3'))
        msb3.config(width=4,height=2,font=(None,15),bg="white",fg="black")
        msb3.grid(row=3,column=0)

        msbs=Button(miscer)
        msbs.config(width=4,height=2,font=(None,15),bg="grey85",fg="grey85")
        msbs.grid(row=4,column=0)

        msb4=Button(miscer, text="Stop", command=lambda:self.txmit('1'))
        msb4.config(width=6,height=4,font=(None,15),bg="red",fg="black")
        msb4.grid(row=6,column=0)

    def dxmit(self, key):
        self.msg = '{D' + key + '}'
        ser.write(self.msg.encode('utf-8'))
        print(self.msg)

    def exmit(self, key):
        self.msg = '{E' + key + '}'
        ser.write(self.msg.encode('utf-8'))
        print(self.msg)

    def fxmit(self, key):
        self.msg = '{F' + key + '}'
        ser.write(self.msg.encode('utf-8'))
        print(self.msg)

    def txmit(self, key):
        self.msg = '{T' + key + '}'
        ser.write(self.msg.encode('utf-8'))
        print(self.msg)

#   Listen to serial port for status info from rover pi ================================
    def listen(self):
        global butngreen
        global butnred
        global butnblack
        global butnblue
        global butnyellow
        global track
        global lat
        global lon
        global rhdg
        global strhdg
        
        while ser.in_waiting:
            inpt = ser.read(1).decode("utf-8")
            if (inpt == '{'):
                self.ibuffer = ""
                continue
            if (inpt == '}'):
                self.piflag = True
                break;
            self.ibuffer = self.ibuffer + inpt

           
        if self.piflag:
            if (len(self.ibuffer) >= 3):
                
                xchar = self.ibuffer[0]
                lbuffer = self.ibuffer[1:]
#                print (self.ibuffer)
                
                if (xchar == 'a'):               # status
                    self.status.set(lbuffer)
                        
                elif (xchar == 'c'):             # course to wpt
                    self.ctg.set(lbuffer)
                        
                elif (xchar == 'd'):             # distance to wpt
                    self.dtg.set(lbuffer)
                        
                elif (xchar == 'h'):
                    self.head.set(lbuffer)
                    rhdg = math.radians(450 - float(lbuffer))
                    guage(root)
                        
                elif (xchar == 'l'):
                    xchar = lbuffer[0]
                    lbuffer = lbuffer[1:]
                    if (xchar == 'a'):          # GPS accuracy
                        self.acc.set(lbuffer)
                    if (xchar == 'x'):          # x-track error
                        self.xte.set(lbuffer)
                    if (xchar == 't'):
                        lat = float(lbuffer)
                    if (xchar == 'n'):
                        lon = float(lbuffer)
                        # TBD dont append if same lat/lon
                        # track.append([lon, lat])
                        xspot(root, lon, lat)
                        
                elif (xchar == 's'):            # steering angle
                    self.steer.set(lbuffer)
                    strhdg = int(lbuffer)
                    guage(root)
                        
                elif (xchar == 'v'):            # speed
                    self.speed.set(lbuffer)
 
            self.piflag = False
            self.ibuffer = ""

        # check tactile buttons
        if (GPIO.input(21) == False):
            if (butngreen == False):
                self.dxmit('6')
                butngreen = True
        else:
            butngreen = False
            
        if (GPIO.input(5) == False):
            if (butnblack == False):
                self.dxmit('5')
                butnblack = True
        else:
            butnblack = False
            
        if (GPIO.input(13) == False):
            if (butnred == False):
                self.dxmit('4')
                butnred = True
        else:
            butnred = False
            
        if (GPIO.input(7) == False):
            if (butnblue == False):
                self.dxmit('2')
                butnblue = True
        else:
            butnblue = False
            
        if (GPIO.input(10) == False):
            if (butnyellow == False):
                self.dxmit('8')
                butnyellow = True
        else:
            butnyellow = False
            
        if pathflag:
            try:
                cdfline = pathfile.readline()
                if (cdfline != ''):
                    line = cdfline.split(',')
                    xspot(root, float(line[2]), float(line[3]))
                    # track.append([float(line[2]), float(line[3])])
                    rhdg = math.radians(450 - float(line[8]))
                    strhdg = int(line[7])
#                    chart(root)
                    guage(root)

            except IOError:
                pass

        root.after(25, self.listen)

root = Tk()
root.wm_title('Rover Controller')
chartform = Frame(root)
chartform.place(x=200, y=20)
canvas= Canvas(chartform, width=600, height=600, bg='white')
canvas.pack()
chart(root)

rosefrm = Frame(root)
rosefrm.place(x = 950, y = 20)
rose = Canvas(rosefrm, width=220, height=220, bg='gray85')
rose.pack()
guage(root)

app = App(root)
root.geometry("1280x800+0+0")

root.after(25, app.listen)
canvas.bind('<B1-Motion>', mouse)
canvas.bind('<Double-Button-1>', taptap)
canvas.bind('<Button-1>', bpress)
canvas.bind('<ButtonRelease>', bupress)

root.mainloop()
